# `paftools` Tutorial

**This tutorial is in initial stages of construction**


## Practical Preparation

### Shell

`paftools` uses a command line interface (CLI) and it is therefore
used from a shell (i.e. "the command line"). This tutorial assumes
some familiarity with the shell. Shell concepts that are useful for
working with `paftools` (and for HPC based scientific computing in
general) include:
* Basic processing of command lines by the shell: A **command line** is broken up into **words** at whitespace characters.
  * The first word is the **command**.
  * Subsequent words are **arguments** to the command.
  * Arguments starting with a minus (aka dash) are typically **options**.
  * Arguments that are not options are called **parameters**.
  * Parameters can be associated with an option, if they are not, they are **positional parameters**.
* There are characters that are special to the shell.
  * Special characters include `*`, `?`, `[`, `]`, `"`, `'`, `\`, `&`, `<`, `>` and several more. Whitespace characters are also special (see above).
  * The letters, digits, and the characters `/`, `-`, `_` are not special.
  * Special characters can be parts of words if they are appropriately **quoted** or **escaped**.
* The shell **expands** file name **globbing** expressions to lists of all files matching the expression. E.g. the globbing expression `*.txt` is expanded to all files ending with `.txt`.
* Running a command usually starts a **process**. There can be multiple processes executing the same command (i.e. program).
* The command running in the foreground can be terminated by pressing Ctrl-C.
* Multiple processes can be managed in one shell, using the **job control** commands:
  * Ctrl-Z stops the foreground process and brings up a shell prompt.
  * `fg %3` makes job number 3 run in the foreground.
  * `bg %4` makes job number 4 run in the background
  Running a command starts a job that initially runs in the foreground, but appending `&` to a command results in the command starting to run in the background.
* Each process has a **standard input**, a **standard output** and a **standard error** (also an output).
  * Standard input and standard output can be **redirected**, using the `<` and `>` operators.
  * The standard input is read from the keyboard (unless redirection is used). Pressing Ctrl-D at the start of a line indicates the **end of file** (i.e. end of input) from the keyboard.
  * The standard output and the standard error appear on the terminal (unless redirection is used).
* The standard output of one process can be connected to the standard input of another process with a **pipe**.

Using `paftools` and participating in this tutorial does not require
full knowledge of all these shell features and concepts. It is,
however, useful to be aware of these concepts, and to notice that the
terms shown **in boldface** in the bullet list above have rigorous
technical definitions. They are likely to come up in this tutorial or
training sessions. Questions on these concepts are welcome ahead of
the tutorial as well as during the tutorial. The [Software Carpentry
Shell Lesson](http://swcarpentry.github.io/shell-novice/) is a useful
resource to get started with the shell, or to refresh your knowledge.


### Docker

Please install [Docker](https://www.docker.com), and familiarise
yourself with
* running a container interactively using the `docker run -t -i` command,
* downloading a container image using the `docker pull` command,
* bind-mounting a directory on your host system using the `--mount type=bind,src=...,dst=...` option to the `docker run` command.

On this basis, run an interactive session of the image
`jttkim/paftol-demo:latest`. If you have data you want to try
processing with `paftools`, put them into a directory on your host
system and bind-mount that directory.


## Introduction

`paftools` is a command line application providing tools for
processing data generated by the [Plant and Fungal Trees of Life
(PAFTOL) project](https://www.paftol.org/). These tools range from
simple utilities to specialised integrated analysis "pipelines" of
considerable complexity.

There is only one shell command, `paftools`, that provides access to
all the tools. The first free parameter to the `paftools` command
specifies the tool to be used.

Throughout paftools, the `-h` option provides help. Specifically,
* `paftools -h` shows help about using the `paftools` command, including a list of all tools (i.e. subcommands),
* `paftools <cmd> -h` shows help about the tool `<cmd>`.

Try running (e.g. in a docker container running the `paftol-demo` image)
```
paftools -h
```
and then use `-h` on a specific command you have found. Share one
question you have about what you've found (e.g. by sending an email
to the PAFTOL data analysis team, or by discussing with your neighbour
in a training session).


## Recover Target Sequences from Fastq Files

The `recoverSeqs` tool is designed to recover target sequences,
provided via a /targets file/. It provides a complex process comprised
of the following stages:
* **Trimming** of reads, currently only trimmomatic is supported  (`--trimmer`)
* **Mapping** of reads, using either BWA or tblastn (`--mapper`)
* **Assembly** of reads into contigs, using spades or the built-in overlap based assembler,
* **Recovery** of coding sequences of the target genes.


### Run Basic Recovery

Start a Docker container running the `jttkim/paftol-demo:latest` image
and navigate to the data/hybpiper directory after logging into the
`paftol` account (using the `su -` command).

Compose a command line to recover sequences based on this method specification:
* no trimming is necessary
* use `tblastn` for mapping
* use the serial overlap assembly method with these parameters:
  * reference alignment: minimum 70% sequence identity within a window of 30 bases
  * overlaps: minimum 90% sequence identity within an overlap window of 20 bases

This will be a lengthy command line, due to the complexity / high
level of integration of the recovery process. Decide on a pair of
fastq files to work with, and then build your command line one option
at a time.

Once you have a command that successfully generates a fasta file of
recovered sequences, extend this to additionally output
* a comma separated values (csv) file containing statistics of the recovery process,
* a `tar.gz` archive of the temporary directory used during the recovery process.

Furthermore, consider the effects of the sequence identity thresholds
and window sizes. How do you expect them to affect the recovery
results? Develop one or more formal and specific predictions, then run
recovery with altered parameters to test these.


## Extract Coding Sequences from Genomes

* `xcds` tool


## Retrieve Target Sequences from Transcriptomes

* `retrievetargets` tool


## Database Related Tools

* `addTargetsFile`
* `addPaftolFastq`


## Housekeeping Tools

* `geneFasta`
* `selectgenes`
* `delgeneNewick`


## Miscellaneous Tools

* `alignmentOutline`


## Experimental Tools

* `xstar`


# Additional Notes

## Outline of the `recoverySeqs` process

The process is comprised of four major stages:

* **Trimming**, which is optional and is requested by the `--trimmer`
  option. The only trimmer currently supported is `trimmomatic`.
* **Read mapping**, which associates ("maps") reads to target genes.
  Mapping is based on sequence similarity and uses an external aligner
  to find similar sequences. Currently, `tblastn` and `bwa` are supported.
* **Assembly** of reads into contigs. Currently, support for `spades`
  and a built-in overlap based assembler are provided.
* **Coding sequence recovery**. This final stage attempts to select a
  subset of contigs that minimises redundancy (i.e. contigs pertaining
  to the same part of a target gene), and pieces a coding sequence together
  from these. This stage heavily relies on the external `exonerate` program.


## Outline of the `overlapSerial` Assembly Process

This process is comprised of the following stages:

* The target to which the largest number of reads were mapped is
  selected as the **reference target sequence**.

* Reads are **ordered** by aligning them to the reference sequence.
  Reads are pairwisely aligned to the reference sequence, and if there
  is a window in the alignment in which relative sequence identity
  meets a given threshold, the alignment start position is used as
  the ordering criterion. This is parameterised by the
  `--windowSizeReference` and `--relIdentityThresholdReference`
  options.

* Consecutive reads within this order are aligned to find **read
  overlaps**. If there is a window in this alignment in which
  relative identity meets a given threshold, the aligned reads are
  added to the same contig. This is parameterised by the
  `--windowSizeReadOverlap` and `--relIdentityThresholdReadOverlap`
  parameters.



## Architecture and Design

`paftools` is essentially a command line interface (CLI) to the Python
module `paftol`. This module provides an Application Programming
Interface (API) of classes designed to formally model concepts
relevant to PAFTOL data analysis. Currently, these are mainly centred
around recovery of target sequences. Additionally, there is support
for phylogeny inference, which however is not as complete at this
time.

Many of the `paftools` is designed to do one thing only, and to do
that well. In other words, they are self contained and carry out their
function regardless of the context. This way, while each tool serves a
purpose that is strictly (and thus perhaps narrowly) defined, the
tools can be combined in a very large number of combinations. Thus,
the design of `paftools` is **orthogonal**. Orthogonality is an
important general design principle that also underpins the design e.g.
of Unix shells, see e.g. the [part
2](http://swcarpentry.github.io/shell-novice/02-filedir/index.html)
and [part
3](http://swcarpentry.github.io/shell-novice/03-create/index.html) of
[Software Carpentry](https://software-carpentry.org/)'s [shell
lesson](http://swcarpentry.github.io/shell-novice/).

As a result of this principle, it's unlikely that for any task you may
have at hand there is already a tool that will specifically carry out
exactly that task. However, the chances are very good that there is a
set of tools you can combine to exactly meet your requirements.

The design of the `paftol` Python module aims to follow the
orthogonality as well. This means that if a tool you need is not (yet)
available, there is a good chance it can be built on the basis of the
`paftol` module relatively straightforwardly. And also, if a
specialised, highly integrated and complex tool is required, it can be
purpose-built as well.

As an example, the `recoverSeqs` tool is very specialised and
integrates a complex set of stages. On the other hand, the tools
summarised as "Housekeeping Tools" above are simple and amenable to
being combined in a multitude of ways.

Finally, **you**, the PAFTOL community, are key to shaping the
development of `paftools`. So, if there is any task or requirement
that you'd like to be met, or any experience you'd like to share,
please get in touch anytime.


## Future Directions

* The stage of CDS recovery from contigs should be separated further
  from the computing of contigs, and options to tailor the process to
  recover "splash zones" should be developed.
* Additional overlap based assembly methods / variants:
  * use reads that don't map to reference to extend contigs
  * full all-vs-all overlap, entirely independent of reference CDS
  * build contigs with high tolerance for divergence, and identify
    alleles / paralogs using read alignments underlying contigs


## Obsolete Tools

As the `paftools` have evolved over the years, some of the tools have
become obsolete. These include:

* `hybpiperBwa`, `hybpiperTblastn`, `overlapRecover`: These have been
  replaced by the more comprehensive and flexible `recoverSeqs` tool.
  Essentially,
  * `hybpiperBwa` is equivalent to `recoverSeqs` --mapper bwa --assembler spades
  * `hybpiperTblastn` is equivalent to `recoverSeqs` --mapper tblastn --assembler spades
  * `overlapRecover` is equivalent to `recoverSeqs` --mapper tblastn --assembler overlapSerial

* `hybseqstats`
